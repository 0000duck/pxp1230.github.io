<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>8. Unity类型扩展和常用数学方法 - </title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style type="text/css">
  body {
  font: 14px/200% "Hiragino Sans GB","Microsoft YaHei",tahoma,arial,simsun;
  color: #00CCFF;
  background: #1A1A1A;
  word-wrap: break-word;
  word-break: normal;
  }
  img {
  max-width:100%;
  }
  html,
  body,
  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  p,
  blockquote,
  ol,
  ul,
  li,
  img,
  li div{
    margin: 0;
    padding: 0;
    font: 14px/200% "Hiragino Sans GB","Microsoft YaHei",tahoma,arial,simsun;
    line-height: 22px;
    vertical-align: baseline;
    color: #00CCFF;
  }
  body {
    margin: 10px;
  }
  p,
  div {
    margin-bottom: 20px;
  }
  strong {
    font-weight: bold;
  }
  ol,
  ul {
    margin-left: 2em;
    margin-bottom: 20px;
  }
  ul ul,
  ol ol,
  ul ol,
  ol ul {
    margin-top: 10px;
  }
  li {
    margin-bottom: 10px;
  }
  h1,
  h2,
  h3,
  h4,
  h5,
  h6 {
    font-weight: lighter;
    text-transform: capitalize;
    margin-top: 20px;
    margin-bottom: 20px;
  }
  h1 {
    font-size: 24.624px;
    line-height: 29.548799999999996px;
  }
  h2 {
    font-size: 24.624px;
    line-height: 29.548799999999996px;
  }
  h3 {
    font-size: 23.44px;
    line-height: 28.128px;
  }
  h4 {
    font-size: 22.16px;
    line-height: 26.592px;
  }
  h5 {
    font-size: 22.16px;
    line-height: 26.592px;
  }
  h6 {
    font-size: 22.16px;
    line-height: 26.592px;
  }
  img {
    margin-bottom: 20px;
  }
  h1 img,
  h2 img,
  h3 img,
  h4 img,
  h5 img,
  h6 img,
  p img {
    margin-bottom: 0;
  }
  pre {
    color: #00CCFF;
    margin-bottom: 20px;
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }
  code {
    font-family:Menlo,Monaco,Consolas,"Andale Mono","lucida console","Courier New",monospace;
    font-size:12px;line-height:1.5;
    box-shadow:0 0 8px rgba(0, 0, 0, 0.4);
    padding:1em !important;
    display:block;
  }
  h1 {
    text-transform: uppercase;
    font-weight: bold;
    border-bottom: 1px solid;
    padding-bottom: 4px;
  }
  h2 {
    border-bottom: 1px solid;
    padding-bottom: 4px;
  }
  h3,
  h4,
  h5,
  h6 {
    border-bottom: none;
  }
  html body {
    background-color: #1A1A1A;
  }
  html h1,
  html h2,
  html h3,
  html h4,
  html h5,
  html h6 {
    color: #FFCC00;
    border-color: #FFCC00;
  }
  html a,
  html a:active,
  html a:visited {
    color: #FFCC00;
  }
  html a:hover {
    background-color: #554400;
  }
  html a,
  html a:active,
  html a:visited,
  html code.url {
    color: #FFCC00;
  }
  html h2,
  html h3,
  html h4,
  html h5,
  html h6 {
    color: #FFCC00;
  }
  hr{
  border:0;background-color:#CC0000;height:4px;margin:40px auto;
  }
  blockquote {
  background:#073642;
  border-left:10px solid #005266;
  margin:1.5em 10px;
  padding:.5em 10px;
  }
  blockquote code {
    color: #00CCFF;
    font-family: "Hiragino Sans GB","Microsoft YaHei",tahoma,arial,simsun;
  }
  blockquote pre {
    margin:0;
    padding:0;
  }
  blockquote p,blockquote div{
    margin-bottom:0;
  }
  strong{color:#FFCC00;}
  </style>
  
  
  <meta charset="UTF-8"/>
  <meta name="author" content="潘霄鹏 - weibo.com/pxp1230">
  <meta name="keywords" content="潘霄鹏笔记">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
  tex2jax: {inlineMath:[['$','$']],processEscapes:true}
  });
  </script>
  <script type="text/javascript"
  src="file:///storage/emulated/0/MathJax-master/MathJax-master/MathJax.js?config=TeX-AMS_HTML">
  </script>
  <script type="text/javascript"
  src="file:///C:/MathJax-master/MathJax-master/MathJax.js?config=TeX-AMS_HTML">
  </script>
  <link rel="stylesheet" href="file:///storage/emulated/0/highlight/styles/pojoaque.css">
  <script type="text/javascript"
  src="file:///storage/emulated/0/highlight/highlight.pack.js">
  </script>
  <link rel="stylesheet" href="file:///C:/highlight/styles/pojoaque.css">
  <script type="text/javascript"
  src="file:///C:/highlight/highlight.pack.js">
  </script>
  <script type="text/javascript">
  document.onkeydown=function(e){if(typeof(disableListenKeyDownEvent)=='undefined'){if(e.keyCode==88||e.keyCode==46){window.open('','_self');window.close()}else if(e.keyCode==8)window.open('index.html','_self')}}
  if(window.location.protocol!="file:"){var d=document,s=d.createElement('script');s.src='/pxp1230.github.io.js';(d.head||d.body).appendChild(s);}else{hljs.initHighlightingOnLoad();}
  </script>
</head>
<body>
<p><strong>● 所有运算遵循左手螺旋定则</strong></p>
<h2 id="vector2ex">Vector2ex</h2>
<p>static readonly Vector2 Zero<br />
Vector2(0.0f, 0.0f)</p>
<p>static readonly Vector2 One<br />
Vector2(1.0f, 1.0f)</p>
<p>static readonly Vector2 UnitX<br />
Vector2(1.0f, 0.0f)</p>
<p>static readonly Vector2 UnitY<br />
Vector2(0.0f, 1.0f)</p>
<p>static readonly Vector2 PositiveInfinity<br />
Vector2(float.PositiveInfinity, float.PositiveInfinity);</p>
<p>static readonly Vector2 NegativeInfinity<br />
Vector2(float.NegativeInfinity, float.NegativeInfinity)</p>
<p>static Vector2 Replicate(float value)<br />
Vector2(value, value)</p>
<p>static float Length(this Vector2 vector)<br />
static float LengthSqr(this Vector2 vector)</p>
<p>static float DotPerp(this Vector2 vector, Vector2 value)<br />
static float DotPerp(this Vector2 vector, ref Vector2 value)<br />
static float DotPerp(ref Vector2 vector, ref Vector2 value)<br />
计算叉乘（x0<em>y1 - y0</em>x1）</p>
<p>static float Dot(this Vector2 vector, Vector2 value)<br />
static float Dot(this Vector2 vector, ref Vector2 value)<br />
static float Dot(ref Vector2 vector, ref Vector2 value)</p>
<p>static Vector2 Perp(this Vector2 vector)<br />
计算垂线，Returns (y,-x)</p>
<p>static float AngleDeg(this Vector2 vector, Vector2 target)<br />
返回值范围 [0..180] range.<br />
static float AngleRad(this Vector2 vector, Vector2 target)<br />
返回值范围 [0..PI] range.</p>
<p>static Vector3 ToVector3XY(this Vector2 vector)<br />
static Vector3 ToVector3XZ(this Vector2 vector)<br />
static Vector3 ToVector3YZ(this Vector2 vector)</p>
<p>static string ToStringEx(this Vector2 vector)</p>
<p>static float Normalize(ref Vector2 vector, float epsilon = MathfEx.ZeroTolerance)<br />
归一化 and returns it's length before normalization.<br />
static float SetLength(ref Vector2 vector, float lengthValue, float epsilon = Mathfex.ZeroTolerance)<br />
设置向量模长. Returns new vector length or 0 if vector's initial length is less than epsilon.<br />
static float GrowLength(ref Vector2 vector, float lengthDelta, float epsilon = Mathfex.ZeroTolerance)<br />
在原模长基础上增加长度. Returns new vector length or 0 if vector's initial length is less than epsilon.</p>
<h2 id="vector3ex">Vector3ex</h2>
<p>static readonly Vector3 Zero<br />
Vector3(0.0f, 0.0f, 0.0f)</p>
<p>static readonly Vector3 One<br />
Vector3(1.0f, 1.0f, 1.0f)</p>
<p>static readonly Vector3 UnitX<br />
Vector3(1.0f, 0.0f, 0.0f)</p>
<p>static readonly Vector3 UnitY<br />
Vector3(0.0f, 1.0f, 0.0f)</p>
<p>static readonly Vector3 UnitZ<br />
Vector3(0.0f, 0.0f, 1.0f)</p>
<p>static readonly Vector3 PositiveInfinity<br />
Vector3(float.PositiveInfinity, float.PositiveInfinity, float.PositiveInfinity)</p>
<p>static readonly Vector3 NegativeInfinity<br />
Vector3(float.NegativeInfinity, float.NegativeInfinity, float.NegativeInfinity)</p>
<p>static Vector3 Replicate(float value)<br />
Vector3(value, value, value)</p>
<p>static float Length(this Vector3 vector)<br />
static float LengthSqr(this Vector3 vector)</p>
<p>static float Dot(this Vector3 vector, Vector3 value)<br />
static float Dot(this Vector3 vector, ref Vector3 value)<br />
static float Dot(ref Vector3 vector, ref Vector3 value)</p>
<p>static float AngleDeg(this Vector3 vector, Vector3 target)<br />
返回值范围 [0..180] range.<br />
static float AngleRad(this Vector3 vector, Vector3 target)<br />
返回值范围 [0..PI] range.<br />
static float SignedAngleDeg(this Vector3 vector, Vector3 target, Vector3 normal)<br />
返回值范围 [-180..180] range.<br />
static float SignedAngleRad(this Vector3 vector, Vector3 target, Vector3 normal)<br />
返回值范围 [-PI..PI] range.<br />
static float AngleDeg(Vector3 v0, Vector3 v1, Vector3 v2)<br />
计算∠102，返回值范围 [0..180] range.<br />
static float AngleRad(Vector3 v0, Vector3 v1, Vector3 v2)<br />
计算∠102，返回值范围 [0..PI] range.<br />
static float SignedAngleDeg(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 normal)<br />
计算∠102，返回值范围 [-180..180] range.<br />
static float SignedAngleRad(Vector3 v0, Vector3 v1, Vector3 v2, Vector3 normal)<br />
计算∠102，返回值范围 [-PI..PI] range.</p>
<p>static Vector3 Cross(this Vector3 vector, Vector3 value)<br />
static Vector3 Cross(this Vector3 vector, ref Vector3 value)<br />
static Vector3 Cross(ref Vector3 vector, ref Vector3 value)<br />
叉乘<br />
static Vector3 UnitCross(this Vector3 vector, Vector3 value)<br />
static Vector3 UnitCross(this Vector3 vector, ref Vector3 value)<br />
static Vector3 UnitCross(ref Vector3 vector, ref Vector3 value)<br />
叉乘，返回值经过归一化</p>
<p>static Vector2 ToVector2XY(this Vector3 vector)<br />
static Vector2 ToVector2XZ(this Vector3 vector)<br />
static Vector2 ToVector2YZ(this Vector3 vector)<br />
static Vector2 ToVector2(this Vector3 vector, ProjectionPlanes projectionPlane)<br />
将vector投影到XY、XZ或YZ平面<br />
static ProjectionPlanes GetProjectionPlane(this Vector3 vector)<br />
例如：三分量里如果y最大，则返回ProjectionPlanes.XZ</p>
<p>static string ToStringEx(this Vector3 vector)</p>
<p>static float Normalize(ref Vector3 vector, float epsilon = MathfEx.ZeroTolerance)<br />
归一化 and returns it's length before normalization.<br />
static float SetLength(ref Vector3 vector, float lengthValue, float epsilon = Mathfex.ZeroTolerance)<br />
设置向量模长. Returns new vector length or 0 if vector's initial length is less than epsilon.<br />
static float GrowLength(ref Vector3 vector, float lengthDelta, float epsilon = Mathfex.ZeroTolerance)<br />
在原模长基础上增加长度. Returns new vector length or 0 if vector's initial length is less than epsilon.</p>
<p>static void CreateOrthonormalBasis(out Vector3 u, out Vector3 v, ref Vector3 w)<br />
根据w生成正交基，w必须是归一化向量. {U,V,W} is an orthonormal basis.</p>
<p>static bool SameDirection(Vector3 value0, Vector3 value1)<br />
判断夹角是否为锐角，Returns true if Dot(value0,value1) &gt; 0<br />
Quaternionex</p>
<p>static Quaternion DeltaTo(this Quaternion Q1, Quaternion Q2)<br />
Q1<em>Q=Q2，返回Q（= Quaternion.Inverse(Q1) </em> Q2）</p>
<p>static string ToStringEx(this Quaternion quat)</p>
<h2 id="matrix4x4ex">Matrix4x4ex</h2>
<p>*Unity使用左乘矩阵，下标顺序如下：<br />
0 4 8 12<br />
1 5 9 13<br />
2 6 10 14<br />
3 7 11 15</p>
<p>static readonly Matrix4x4 Identity</p>
<p>static void RotationMatrixToQuaternion(ref Matrix4x4 matrix, out Quaternion quaternion)<br />
static void QuaternionToRotationMatrix(Quaternion quaternion, out Matrix4x4 matrix)<br />
static void QuaternionToRotationMatrix(ref Quaternion quaternion, out Matrix4x4 matrix)<br />
Quaternion、Matrix4x4互转</p>
<p>创建几何变换矩阵：<br />
static void CreateTranslation(Vector3 position, out Matrix4x4 matrix)<br />
static void CreateTranslation(ref Vector3 position, out Matrix4x4 matrix)<br />
static void CreateScale(Vector3 scale, out Matrix4x4 matrix)<br />
static void CreateScale(ref Vector3 scale, out Matrix4x4 matrix)<br />
static void CreateScale(float scale, out Matrix4x4 matrix)<br />
static void CreateRotationEuler(float eulerX, float eulerY, float eulerZ, out Matrix4x4 matrix)<br />
static void CreateRotationEuler(Vector3 eulerAngles, out Matrix4x4 matrix)<br />
static void CreateRotationEuler(ref Vector3 eulerAngles, out Matrix4x4 matrix)<br />
(order is the same as in Quaternion.Euler() method)<br />
static void CreateRotationX(float angleInDegrees, out Matrix4x4 matrix)<br />
static void CreateRotationY(float angleInDegrees, out Matrix4x4 matrix)<br />
static void CreateRotationZ(float angleInDegrees, out Matrix4x4 matrix)<br />
static void CreateRotationAngleAxis(float angleInDegrees, Vector3 rotationAxis, out Matrix4x4 matrix)<br />
(function will normalize axis)<br />
static void CreateRotationAngleUnitAxis(float angleInDegrees, Vector3 normalizedAxis, out Matrix4x4 matrix)<br />
(caller must provide unit-length axis)<br />
static void CreateRotation(Vector3 rotationOrigin, Quaternion rotation, out Matrix4x4 result)<br />
static void CreateRotation(ref Vector3 rotationOrigin, ref Quaternion rotation, out Matrix4x4 result)<br />
static void CreateSRT(Vector3 scaling, Quaternion rotation, Vector3 translation, out Matrix4x4 result)<br />
static void CreateSRT(ref Vector3 scaling, ref Quaternion rotation, ref Vector3 translation, out Matrix4x4<br />
result)<br />
顺序: scaling, rotation, translation.<br />
static void CreateSRT(float scaling, Quaternion rotation, Vector3 translation, out Matrix4x4 result)<br />
static void CreateSRT(float scaling, ref Quaternion rotation, ref Vector3 translation, out Matrix4x4<br />
result)<br />
顺序: uniform scaling, rotation, translation.<br />
static void CreateSRT(Vector3 scaling, Vector3 rotationOrigin, Quaternion rotation, Vector3 translation,<br />
out Matrix4x4 result)<br />
static void CreateSRT(ref Vector3 scaling, ref Vector3 rotationOrigin, ref Quaternion rotation, ref Vector3<br />
translation, out Matrix4x4 result)<br />
顺序: scaling, moving to rotation origin, rotation, moving to translation point.<br />
static void CreateSRT(float scaling, Vector3 rotationOrigin, Quaternion rotation, Vector3 translation, out<br />
Matrix4x4 result)<br />
static void CreateSRT(float scaling, ref Vector3 rotationOrigin, ref Quaternion rotation, ref Vector3<br />
translation, out Matrix4x4 result)<br />
顺序: uniform scaling, moving to rotation origin, rotation, moving to translation point.<br />
static void CreateRT(Quaternion rotation, Vector3 translation, out Matrix4x4 result)<br />
static void CreateRT(ref Quaternion rotation, ref Vector3 translation, out Matrix4x4 result)<br />
顺序: rotation, translation.<br />
static void CreateRT(Vector3 rotationOrigin, Quaternion rotation, Vector3 translation, out Matrix4x4<br />
result)<br />
static void CreateRT(ref Vector3 rotationOrigin, ref Quaternion rotation, ref Vector3 translation, out<br />
Matrix4x4 result)<br />
顺序: moving to rotation origin, rotation, moving to translation point.<br />
static void CreateST(Vector3 scaling, Vector3 translation, out Matrix4x4 result)<br />
static void CreateST(ref Vector3 scaling, ref Vector3 translation, out Matrix4x4 result)<br />
顺序无关<br />
static void CreateRotationFromColumns(Vector3 column0, Vector3 column1, Vector3 column2, out Matrix4x4<br />
matrix)<br />
static void CreateRotationFromColumns(ref Vector3 column0, ref Vector3 column1, ref Vector3 column2, out<br />
Matrix4x4 matrix)</p>
<p>static void Transpose(ref Matrix4x4 matrix, out Matrix4x4 transpose)<br />
static void Transpose(ref Matrix4x4 matrix)<br />
转置矩阵</p>
<p>static float CalcDeterminant(ref Matrix4x4 matrix)<br />
行列式</p>
<p>static void Inverse(ref Matrix4x4 matrix, out Matrix4x4 inverse, float epsilon = MathfEx.ZeroTolerance)<br />
static void Inverse(ref Matrix4x4 matrix, float epsilon = MathfEx.ZeroTolerance)<br />
逆矩阵</p>
<p>static void CopyMatrix(ref Matrix4x4 source, out Matrix4x4 destination)<br />
拷贝</p>
<p>矩阵乘法：<br />
static void Multiply(ref Matrix4x4 matrix0, ref Matrix4x4 matrix1, out Matrix4x4 result)<br />
static void Multiply(ref Matrix4x4 matrix, float scalar)<br />
static void Multiply(ref Matrix4x4 matrix, float scalar, out Matrix4x4 result)<br />
static Vector4 Multiply(ref Matrix4x4 matrix, Vector4 vector)<br />
static Vector4 Multiply(ref Matrix4x4 matrix, ref Vector4 vector)<br />
matrix*vector</p>
<p>创建投影变换矩阵：<br />
static void CreateShadowDirectional(Plane3 shadowPlane, Vector3 dirLightOppositeDirection, out Matrix4x4 result)<br />
static void CreateShadowDirectional(ref Plane3 shadowPlane, ref Vector3 dirLightOppositeDirection, out Matrix4x4 result)<br />
平行投影矩阵（参数dirLightOppositeDirection是平行光照射的反方向）<br />
static void CreateShadowPoint(Plane3 shadowPlane, Vector3 pointLightPosition, out Matrix4x4 result)<br />
static void CreateShadowPoint(ref Plane3 shadowPlane, ref Vector3 pointLightPosition, out Matrix4x4 result)<br />
透视投影矩阵（参数pointLightPosition是点光源位置）<br />
static void CreateShadow(Plane3 shadowPlane, Vector4 lightData, out Matrix4x4 result)<br />
static void CreateShadow(ref Plane3 shadowPlane, ref Vector4 lightData, out Matrix4x4 result)<br />
投影矩阵（参数lightData可以是平行光也可以是点光源，lightData.w为0时是平行光照射的反方向，lightData.w为1时是点光源位置）</p>
<h2 id="mathfex">Mathfex</h2>
<p>const float ZeroTolerance<br />
1E-5f<br />
const float NegativeZeroTolerance<br />
-1E-5f<br />
const float ZeroToleranceSqr<br />
(1E-5f)^2<br />
const float Pi<br />
π<br />
const float HalfPi = 0.5f * Pi<br />
π/2<br />
const float TwoPi = 2f * Pi<br />
2π</p>
<p>static float EvalInvCubic(float x)<br />
计算x^1/3<br />
static float EvalQuadratic(float x, float a, float b, float c)<br />
计算二次方程式a<em>x^2 + b</em>x + c<br />
static float EvalSigmoid(float x)<br />
计算S型方程式x^2 * (3 - 2<em>x)，用于缓动动画（x=0→1）<br />
static float EvalGaussian(float x, float a, float b, float c)<br />
计算一维正态分布a </em> e^(-(x-b) 2 / 2<em>c 2 )<br />
static float EvalGaussian2D(float x, float y, float x0, float y0, float A, float a, float b, float c)<br />
计算二维正态分布A </em> e^(-(a<em>(x - x0) 2 + 2</em>b<em>(x - x0)</em>(y - y0) + c*(y - y0) 2 ))<br />
static float InvSqrt(float value)<br />
计算1/√value</p>
<p>插值算法：<br />
static float Lerp(float value0, float value1, float factor)<br />
线性插值，参数factor will be clamped in [0..1]<br />
static float LerpUnclamped(float value0, float value1, float factor)<br />
static float SigmoidInterp(float value0, float value1, float factor)<br />
S型插值，参数factor will be clamped in [0..1]<br />
static float SinInterp(float value0, float value1, float factor)<br />
Sin插值，参数factor will be clamped in [0..1]<br />
static float CosInterp(float value0, float value1, float factor)<br />
Cos插值，参数factor will be clamped in [0..1]<br />
static float WobbleInterp(float value0, float value1, float factor)<br />
弹簧插值（弹簧固定点在终点），参数factor will be clamped in [0..1]<br />
static float CurveInterp(float value0, float value1, float factor, AnimationCurve curve)<br />
动画曲线插值，参数factor will be clamped in [0..1]<br />
static float FuncInterp(float value0, float value1, float factor, System.Func<float, float> func)<br />
自定义函数插值，参数factor will be clamped in [0..1]</p>
<p>static bool Near(float value0, float value1, float epsilon = Mathfex.ZeroTolerance)<br />
返回abs(v0-v1)&lt;eps<br />
static bool NearZero(float value, float epsilon = Mathfex.ZeroTolerance)<br />
返回abs(v)<eps

坐标转换：
static Vector2 CartesianToPolar(Vector2 cartesianCoordinates)
2D笛卡尔坐标转换成2D极坐标（长度x >= 0, 0 <= 弧度y < 2pi）
示例：(0,0)→(0,0)
static Vector2 PolarToCartesian(Vector2 polarCoordinates)
2D极坐标转换成2D笛卡尔坐标
static Vector3 CartesianToSpherical(Vector3 cartesianCoordinates)
3D笛卡尔坐标转换成3D球面坐标（长度x >= 0, 0 <= XZ平面上与X轴的夹角弧度y < 2pi, 0 <= 与Y轴的夹角弧度z < pi）
示例：(0,0,0)→(0,0,0)
static Vector3 SphericalToCartesian(Vector3 sphericalCoordinates)
3D球面坐标转换成3D笛卡尔坐标
static Vector3 CartesianToCylindrical(Vector3 cartesianCoordinates)
3D笛卡尔坐标转换成3D柱面坐标（XZ平面极坐标x >= 0, 0 &lt;= XZ平面极坐标y &lt; 2pi, 高度z）<br />
static Vector3 CylindricalToCartesian(Vector3 cylindricalCoordinates)<br />
3D柱面坐标转换成3D笛卡尔坐标</p>
</body>
</html>
