## 解线性方程组 - LinearSystem类 ##

求A*X=B的解（A是2x2矩阵、3x3矩阵、NxN矩阵）：
Solve2(float[,] A, float[] B, out float[] X, float zeroTolerance)
Solve2(float[,] A, float[] B, out Vector2 X, float zeroTolerance)
Solve3(float[,] A, float[] B, out float[] X, float zeroTolerance)
Solve3(float[,] A, float[] B, out Vector3 X, float zeroTolerance)
Solve(float[,] A, float[] B, out float[] X)
SolveTridiagonal(float[] A, float[] B, float[] C, float[] RightSide, out float[] X)
三对角矩阵：
A - 低一行的对角线
B - 主对角线
C - 高一行的对角线
以4x4矩阵为例：
B	C	0	0
A	B	C	0
0	A	B	C
0	0	A	B
Inverse(float[,] A, out float[,] invA)
求A矩阵的逆矩阵，如果A没有逆矩阵则返回null

## 求矩阵的特征值和特征向量 - EigenDecomposition类 ##

static EigenData Solve(float[,] symmetricSquareMatrix, bool increasingSort);
参数1必须是对称方阵

## 多项式相关计算 - RootFinder类、Polynomial类 ##

RootFinder类 - 求多项式的根：
● N次多项式，x的次数从N到0排列，多项式值为0，例如：c4\*x^4+c3\*x^3+c2\*x^2+c1\*x+c0 = 0
Linear(float c0, float c1, out float root, float epsilon = MathfEx.ZeroTolerance)
N=1
Quadratic(float c0, float c1, float c2, out QuadraticRoots roots, float epsilon)
N=2
Cubic(float c0, float c1, float c2, float c3, out CubicRoots roots, float epsilon)
N=3
Quartic(float c0, float c1, float c2, float c3, float c4, out QuarticRoots roots, float epsilon)
N=4
PolynomialBound(Polynomial poly, float epsilon)
获取根的范围（[-return..return]），返回-1表示多项式为常数
Polynomial(Polynomial poly, float xMin, float xMax, out float[] roots, int digits, float epsilon)
N=?
Polynomial(Polynomial poly, out float[] roots, int digits, float epsilon)
N=?
BrentsMethod(Func<float, float> function, float x0, float x1, out BrentsRoot root, int maxIterations, float negativeTolerance, float positiveTolerance, float stepTolerance, float segmentTolerance)
求多项式根的Brent解法：

Polynomial类：
● float this[int index]构造，顺序如：c0 + c1\*x + c2\*x^2, array will be [c0,c1,c2]
Polynomial CalcDerivative();
返回多项式的导数
void Compress(float epsilon = MathfEx.ZeroTolerance);
压缩多项式：删除系数近似于0的项，最高次项系数转换成1
float Eval(float t);
求多项式的值

## 求解常微分方程 ##

常微分方程：y'(t) = F(t,y)，求y
例如已知y'(t) = (cos(t))^2 - tan(t) \* y(t)，y(0) = 2，解得y(t)=(sin(t) + 2) \* cos(t)
Euler法 - OdeEuler类：用法参考OdeRungeKutta4类
中值法 - OdeMidpoint类：用法参考OdeRungeKutta4类
四阶龙格-库塔法（最精确） - OdeRungeKutta4类：
```
float t = 0.0f;//起始值
float tEnd = 4.0f;
float tStep = 0.3f;
float[] y = { 2.0f };//需要指定一个起始值，如y[0]=y(t)、y[1]=y'(t)、y[2]=y''(t)……
//如_yd[0]=y'(t)、_yd[1]=y'’(t)……
Dest.Math.OdeFunction Func = delegate(float _t, float[] _y, float[] _yd) { _yd[0] = Mathf.Pow(Mathf.Cos(_t), 2) - Mathf.Tan(_t) * _y[0]; };
//这里演示的是一阶常微分方程，所以参数1为1
OdeRungeKutta4 rkSolver = new OdeRungeKutta4(1, tStep, Func);
List<Vector2> rkPoints = new List<Vector2>();
while (t < tEnd)
{
	rkPoints.Add(new Vector2(t, y[0]));
	rkSolver.Update(t, y, ref t, y);
}
```

## 计算一重积分 - Integrator类 ##

static float TrapezoidRule(Func<float, float> function, float a, float b, int sampleCount)
Evaluates integral ∫f(x)dx on [a,b] interval using trapezoidal rule. sampleCount must be greater or equal to 2.
示例：Integrator.TrapezoidRule((x) => { return Mathf.Sin(x) + 2; }, xStart, xEnd, 10);

static float RombergIntegral(Func<float, float> function, float a, float b, int order)
Evaluates integral ∫f(x)dx on [a,b] interval using Romberg's method. Integration order must be positive (order > 0).
示例：Integrator.RombergIntegral((x) => { return Mathf.Sin(x) + 2; }, xStart, xEnd, 4);

static float GaussianQuadrature(Func<float, float> function, float a, float b)
Evaluates integral ∫f(x)dx on [a,b] interval using Gaussian quadrature rule (five Legendre polynomials).
示例：Integrator.GaussianQuadrature((x) => { return Mathf.Sin(x) + 2; }, xStart, xEnd);













